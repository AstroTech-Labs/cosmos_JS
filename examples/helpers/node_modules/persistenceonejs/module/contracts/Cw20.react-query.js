import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.14.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
import { useQuery } from "@tanstack/react-query";
export const cw20QueryKeys = {
  contract: [{
    contract: "cw20"
  }],
  address: contractAddress => [_objectSpread(_objectSpread({}, cw20QueryKeys.contract[0]), {}, {
    address: contractAddress
  })],
  balance: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "balance",
    args
  })],
  tokenInfo: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "token_info",
    args
  })],
  minter: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "minter",
    args
  })],
  allowance: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "allowance",
    args
  })],
  allAllowances: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "all_allowances",
    args
  })],
  allAccounts: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "all_accounts",
    args
  })],
  marketingInfo: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "marketing_info",
    args
  })],
  downloadLogo: (contractAddress, args) => [_objectSpread(_objectSpread({}, cw20QueryKeys.address(contractAddress)[0]), {}, {
    method: "download_logo",
    args
  })]
};
export function useCw20DownloadLogoQuery({
  client,
  options
}) {
  return useQuery(cw20QueryKeys.downloadLogo(client?.contractAddress), () => client ? client.downloadLogo() : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20MarketingInfoQuery({
  client,
  options
}) {
  return useQuery(cw20QueryKeys.marketingInfo(client?.contractAddress), () => client ? client.marketingInfo() : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20AllAccountsQuery({
  client,
  args,
  options
}) {
  return useQuery(cw20QueryKeys.allAccounts(client?.contractAddress, args), () => client ? client.allAccounts({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20AllAllowancesQuery({
  client,
  args,
  options
}) {
  return useQuery(cw20QueryKeys.allAllowances(client?.contractAddress, args), () => client ? client.allAllowances({
    limit: args.limit,
    owner: args.owner,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20AllowanceQuery({
  client,
  args,
  options
}) {
  return useQuery(cw20QueryKeys.allowance(client?.contractAddress, args), () => client ? client.allowance({
    owner: args.owner,
    spender: args.spender
  }) : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20MinterQuery({
  client,
  options
}) {
  return useQuery(cw20QueryKeys.minter(client?.contractAddress), () => client ? client.minter() : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20TokenInfoQuery({
  client,
  options
}) {
  return useQuery(cw20QueryKeys.tokenInfo(client?.contractAddress), () => client ? client.tokenInfo() : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}
export function useCw20BalanceQuery({
  client,
  args,
  options
}) {
  return useQuery(cw20QueryKeys.balance(client?.contractAddress, args), () => client ? client.balance({
    address: args.address
  }) : Promise.reject(new Error("Invalid client")), _objectSpread(_objectSpread({}, options), {}, {
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }));
}